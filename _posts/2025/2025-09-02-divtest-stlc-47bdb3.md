---
title: "Divtest STLC"
slug: "divtest-stlc-47bdb3"
author: Divya
owner: Divya
categories: Public
classification: Public
tags: [auto-import, technology]
date: 2025-11-18 06:03:00
likes: 0
imported: True 
import-source: "content-manager"
import-reference: "25/828596"
import-config-id: "db27bcef-045c-4f13-9270-027bf7488f0f"
---

Software Testing Life Cycle (STLC): A value-driven approach
Test A departmental approach to delivering quality-driven digital solutions.

[Updated for Divya – 02/09/2025 16:15PM]
Types of Testing in STLC
To ensure quality across all dimensions, different types of testing are applied throughout the Software Testing Life Cycle:
Functional Testing: Verifies that the application meets business and user requirements.
Regression Testing: Ensures new changes do not break existing functionality.
Integration Testing: Validates interactions between modules and external systems.
System Testing: Confirms the end-to-end behavior of the complete solution.
User Acceptance Testing (UAT): Confirms the system is ready for real-world use by business stakeholders.
Non-Functional Testing: Covers performance, security, usability, and accessibility.

Benefits of Following STLC
Detects defects early, reducing cost and rework.
Promotes continuous feedback and improvement.
Builds confidence in the product before release.
Provides a structured approach for both manual and automated testing.
Aligns testing with business goals and user value.

Role of Testers in STLC
Testers are not just defect finders but quality advocates. They:
Collaborate with developers, business analysts, and product owners.
Contribute to requirement reviews and risk assessments.
Design test cases, execute tests, and report findings.
Provide insights to improve product usability and performance.

Types of Testing in STLC
To ensure quality across all dimensions, different types of testing are applied throughout the Software Testing Life Cycle:
Functional Testing: Verifies that the application meets business and user requirements.
Regression Testing: Ensures new changes do not break existing functionality.
Integration Testing: Validates interactions between modules and external systems.
System Testing: Confirms the end-to-end behavior of the complete solution.
User Acceptance Testing (UAT): Confirms the system is ready for real-world use by business stakeholders.
Non-Functional Testing: Covers performance, security, usability, and accessibility.

Benefits of Following STLC
Detects defects early, reducing cost and rework.
Promotes continuous feedback and improvement.
Builds confidence in the product before release.
Provides a structured approach for both manual and automated testing.
Aligns testing with business goals and user value.

Role of Testers in STLC
Testers are not just defect finders but quality advocates. They:
Collaborate with developers, business analysts, and product owners.
Contribute to requirement reviews and risk assessments.
Design test cases, execute tests, and report findings.
Provide insights to improve product usability and performance.

TL;DR
Our STLC is a value-driven framework for ensuring digital solutions are tested in a way that is fast, safe, and centred on real user needs. It balances strategy, structure, and adaptability—empowering teams to build confidence, manage risk, and deliver meaningful outcomes through continuous quality, collaboration, and purpose.
The Software Testing Life Cycle (STLC) ensures software quality through a structured, step-by-step approach—from analyzing requirements to planning, designing, executing, and closing tests. Following STLC helps detect defects early, reduce costs, and deliver reliable, high-performing software aligned with business goals.
Start with WHY
To validate and ensure digital solutions are reliable, usable, and valuable—delivered faster, safer, and with confidence.
Driven by our values
Customers first: We test with real user scenarios, ensuring solutions meet actual needs.
Ideas in action: We test early and often, learning quickly from results.
Unleash potential: We empower testers to collaborate across teams and share ownership of quality.
Be courageous: We challenge assumptions and highlight risks openly.
Empower people: We create transparency, enabling teams and stakeholders to trust test outcomes.
What is STLC?
The Software Testing Life Cycle is not just a set of steps—it’s a framework of practices that ensure solutions are validated at every stage.- Software: What we test isn’t just code—it’s the full digital product and experience.- Testing: A discipline that assures functionality, performance, usability, and security.- Life: Testing evolves continuously with the product, adapting to change.- Cycle: Testing is iterative, not linear—it loops as requirements evolve and products mature.
Guiding Principles
Quality is built-in, not inspected at the end.
Testing provides confidence, not just defect counts.
Shift-left & shift-right: testing happens from requirements to production monitoring.
Collaboration between devs, testers, and users ensures shared ownership of quality.
Simplicity and automation accelerate delivery, while manual insight ensures usability.
Pillars of Success
User-centred validation: Tests simulate real-world usage.
Outcome-focused: Measure success by user value, not just passed test cases.
Continuous quality: Testing is embedded into CI/CD pipelines.
Smaller is safer: Incremental testing avoids late surprises.
Sustainable practices: Test assets evolve with the product.
Lean governance: Risk-based test sign-off—just enough, just in time.
STLC: A brief history
1970s – Waterfall testing: Testing at the end; long cycles.
1990s – Iterative models: Testing integrated earlier, defect prevention focus.
2000s – Agile & Shift-Left: Testing embedded in sprints; early defect detection.
2010s – Continuous testing: CI/CD pipelines, automation-first strategies.
2020s – Quality as culture: Testers, devs, designers, and users all share responsibility.
Practices of STLC (with Automation)
Requirement Analysis – Understand user stories, acceptance criteria, and risks. Identify automation candidates (regression-heavy, repetitive, high-risk areas).
Test Planning – Define strategy, scope, resources, and risk approach. Select automation frameworks (e.g., Selenium, Playwright, Cypress).
Test Case Design – Create manual and automated test scenarios covering functional, non-functional, and edge cases. Implement data-driven testing.
Test Environment Setup – Prepare environments, data, and tools. Use Docker, Selenium Grid, or BrowserStack for scalable automation.
Test Execution – Run automated suites via CI/CD pipelines. Publish results in dashboards (Allure, Extent Reports). Manual testing focuses on exploratory & usability.
Defect Reporting & Tracking – Automated failures logged in Jira/Zephyr with screenshots or logs. Alerts integrated with Slack/Teams.
Test Closure & Learning – Capture automation coverage metrics, reuse scripts for smoke/regression testing in future releases.
Automation in STLC
Automation is a discipline embedded across the entire testing life cycle. It accelerates feedback, increases coverage, and reduces repetitive manual effort.
⚙️ Automation Tools by Category:
UI Testing: Selenium, Playwright, Cypress
API Testing: RestAssured, Postman (Newman), Karate
Performance Testing: JMeter, k6, Gatling
Security: OWASP ZAP, dependency scanning
Collaboration & Test Management: Jira, Zephyr, TestRail
CI/CD Integration: Jenkins, Bamboo, GitHub Actions, GitLab CI
Reporting: Allure, ExtentReports, JUnit/TestNG Reports
Cloud Testing: BrowserStack, SauceLabs
Benefits of Automation in STLC
Faster feedback – daily confidence in builds.
Consistency – same tests run across environments.
Scalability – thousands of cases executed in parallel.
Reduced manual effort – testers focus on exploratory testing.
Supports shift-left (automation starts early) and shift-right (monitoring in production).
STLC – A practice with purpose
By embedding testing and automation as value-driven disciplines, we:- Deliver reliable, secure, and user-friendly products.- Prevent costly rework by catching defects early.- Build trust and confidence in solutions across teams and stakeholders.- Promote continuous learning and improvement.Ultimately, STLC provides clarity of quality, confidence in releases, and assurance that what we build delivers real value.
