---
title: "Divtest STLC"
slug: "divtest-stlc-47bdb3"
author: Divya
owner: Divya
categories: Public
classification: Public
tags: [auto-import, technology]
date: 2025-09-02 04:03:06
likes: 0
imported: True 
import-source: "content-manager"
import-reference: "25/828596"
import-config-id: "db27bcef-045c-4f13-9270-027bf7488f0f"
---

# Software Testing Life Cycle (STLC): A Value-Driven Approach

A departmental approach to delivering quality-driven digital solutions.

## TL;DR
Our STLC is a value-driven framework for ensuring digital solutions are tested in a way that is fast, safe, and centred on real user needs. It balances strategy, structure, and adaptability—empowering teams to build confidence, manage risk, and deliver meaningful outcomes through continuous quality, collaboration, and purpose.

The Software Testing Life Cycle (STLC) ensures software quality through a structured, step-by-step approach—from analysing requirements to planning, designing, executing, and closing tests. Following STLC helps detect defects early, reduce costs, and deliver reliable, high-performing software aligned with business goals.

## Start with WHY
To validate and ensure digital solutions are reliable, usable, and valuable—delivered faster, safer, and with confidence.

## Driven by Our Values
- **Customers first:** We test with real user scenarios, ensuring solutions meet actual needs.
- **Ideas in action:** We test early and often, learning quickly from results.
- **Unleash potential:** We empower testers to collaborate across teams and share ownership of quality.
- **Be courageous:** We challenge assumptions and highlight risks openly.
- **Empower people:** We create transparency, enabling teams and stakeholders to trust test outcomes.

## What is STLC?
The Software Testing Life Cycle is not just a set of steps—it’s a framework of practices that ensure solutions are validated at every stage.
- **Software:** What we test isn’t just code—it’s the full digital product and experience.
- **Testing:** A discipline that assures functionality, performance, usability, and security.
- **Life:** Testing evolves continuously with the product, adapting to change.
- **Cycle:** Testing is iterative, not linear—it loops as requirements evolve and products mature.

## Guiding Principles
- Quality is built-in, not inspected at the end.
- Testing provides confidence, not just defect counts.
- Shift-left & shift-right: testing happens from requirements to production monitoring.
- Collaboration between devs, testers, and users ensures shared ownership of quality.
- Simplicity and automation accelerate delivery, while manual insight ensures usability.

## Pillars of Success
- **User-centred validation:** Tests simulate real-world usage.
- **Outcome-focused:** Measure success by user value, not just passed test cases.
- **Continuous quality:** Testing is embedded into CI/CD pipelines.
- **Smaller is safer:** Incremental testing avoids late surprises.
- **Sustainable practices:** Test assets evolve with the product.
- **Lean governance:** Risk-based test sign-off—just enough, just in time.

## STLC: A Brief History
- **1970s:** Waterfall testing: Testing at the end; long cycles.
- **1990s:** Iterative models: Testing integrated earlier, defect prevention focus.
- **2000s:** Agile & Shift-Left: Testing embedded in sprints; early defect detection.
- **2010s:** Continuous testing: CI/CD pipelines, automation-first strategies.
- **2020s:** Quality as culture: Testers, devs, designers, and users all share responsibility.

## Practices of STLC (with Automation)
- **Requirement Analysis:** Understand user stories, acceptance criteria, and risks. Identify automation candidates (regression-heavy, repetitive, high-risk areas).
- **Test Planning:** Define strategy, scope, resources, and risk approach. Select automation frameworks (e.g., Selenium, Playwright, Cypress).
- **Test Case Design:** Create manual and automated test scenarios covering functional, non-functional, and edge cases. Implement data-driven testing.
- **Test Environment Setup:** Prepare environments, data, and tools. Use Docker, Selenium Grid, or BrowserStack for scalable automation.
- **Test Execution:** Run automated suites via CI/CD pipelines. Publish results in dashboards (Allure, Extent Reports). Manual testing focuses on exploratory & usability.
- **Defect Reporting & Tracking:** Automated failures logged in Jira/Zephyr with screenshots or logs. Alerts integrated with Slack/Teams.
- **Test Closure & Learning:** Capture automation coverage metrics, reuse scripts for smoke/regression testing in future releases.

## Automation in STLC
Automation is a discipline embedded across the entire testing life cycle. It accelerates feedback, increases coverage, and reduces repetitive manual effort.

### ⚙️ Automation Tools by Category:
- **UI Testing:** Selenium, Playwright, Cypress
- **API Testing:** RestAssured, Postman (Newman), Karate
- **Performance Testing:** JMeter, k6, Gatling
- **Security:** OWASP ZAP, dependency scanning
- **Collaboration & Test Management:** Jira, Zephyr, TestRail
- **CI/CD Integration:** Jenkins, Bamboo, GitHub Actions, GitLab CI
- **Reporting:** Allure, ExtentReports, JUnit/TestNG Reports
- **Cloud Testing:** BrowserStack, SauceLabs

## Benefits of Automation in STLC
- Faster feedback – daily confidence in builds.
- Consistency – same tests run across environments.
- Scalability – thousands of cases executed in parallel.
- Reduced manual effort – testers focus on exploratory testing.
- Supports shift-left (automation starts early) and shift-right (monitoring in production).

## STLC – A Practice with Purpose
By embedding testing and automation as value-driven disciplines, we:
- Deliver reliable, secure, and user-friendly products.
- Prevent costly rework by catching defects early.
- Build trust and confidence in solutions across teams and stakeholders.
- Promote continuous learning and improvement.

Ultimately, STLC provides clarity of quality, confidence in releases, and assurance that what we build delivers real value.